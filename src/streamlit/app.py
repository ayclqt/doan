#!/usr/bin/env python3
"""
·ª®ng d·ª•ng Streamlit ƒë∆°n gi·∫£n cho Chatbot gi·ªõi thi·ªáu s·∫£n ph·∫©m
Phi√™n b·∫£n s·∫°ch v·ªõi token validation
"""

import asyncio
import json
import os
import time
from dotenv import load_dotenv
from datetime import datetime, timedelta
from typing import Any, AsyncGenerator, Dict, Optional

import aiohttp

import streamlit as st

__author__ = "L√¢m Quang Tr√≠"
__copyright__ = "Copyright 2025, L√¢m Quang Tr√≠"
__credits__ = ["L√¢m Quang Tr√≠"]

__maintainer__ = "L√¢m Quang Tr√≠"
__email__ = "quangtri.lam.9@gmail.com"
__status__ = "Development"

# ================== CONFIGURATION ==================
load_dotenv()  # T·∫£i bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env n·∫øu c√≥
API_BASE_URL = os.getenv("API_KEY_URL", "http://localhost:8000")
API_TIMEOUT = os.getenv("API_TIMEOUT", 300)
MAX_MESSAGE_LENGTH = os.getenv("MAX_MESSAGE_LENGTH", 1000)
SESSION_TIMEOUT_MINUTES = os.getenv("SESSION_TIMEOUT_MINUTES", 30)

# ================== STREAMLIT CONFIG ==================
st.set_page_config(
    page_title="Chatbot Gi·ªõi Thi·ªáu S·∫£n Ph·∫©m",
    page_icon="ü§ñ",
    layout="wide",
    initial_sidebar_state="expanded",
)

# ================== CSS STYLES ==================
st.markdown(
    """
<style>
.stApp > header {
    background-color: transparent;
}

.stApp {
    margin-top: -80px;
}

.stButton > button {
    width: 100%;
    margin-bottom: 0.5rem;
}

.typing-indicator {
    opacity: 0.7;
    font-style: italic;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 0.7; }
    50% { opacity: 1; }
    100% { opacity: 0.7; }
}
</style>
""",
    unsafe_allow_html=True,
)


# ================== UTILITY FUNCTIONS ==================
def run_async(coro):
    """Helper ƒë·ªÉ ch·∫°y async functions trong Streamlit"""
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            import concurrent.futures

            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(asyncio.run, coro)
                return future.result()
        else:
            return loop.run_until_complete(coro)
    except RuntimeError:
        return asyncio.run(coro)


def init_session_state():
    """Kh·ªüi t·∫°o session state"""
    default_values = {
        "authenticated": False,
        "user_info": None,
        "access_token": None,
        "token_expires": None,
        "current_conversation_id": None,
        "messages": [],
        "conversations": [],
        "last_activity": datetime.now(),
        "api_status": "unknown",
    }

    for key, value in default_values.items():
        if key not in st.session_state:
            st.session_state[key] = value


def is_session_valid() -> bool:
    """Ki·ªÉm tra session c√≥ h·ª£p l·ªá kh√¥ng"""
    if not st.session_state.get("authenticated", False):
        return False

    if not st.session_state.get("access_token"):
        return False

    last_activity = st.session_state.get("last_activity")
    if not last_activity:
        return False

    # Ki·ªÉm tra timeout
    if datetime.now() - last_activity > timedelta(minutes=SESSION_TIMEOUT_MINUTES):
        return False

    return True


def update_activity():
    """C·∫≠p nh·∫≠t th·ªùi gian ho·∫°t ƒë·ªông cu·ªëi"""
    st.session_state.last_activity = datetime.now()


def clear_session():
    """X√≥a session state"""
    keys_to_clear = [
        "authenticated",
        "user_info",
        "access_token",
        "token_expires",
        "current_conversation_id",
        "messages",
        "conversations",
    ]
    for key in keys_to_clear:
        if key in st.session_state:
            del st.session_state[key]
    init_session_state()


def handle_token_error():
    """X·ª≠ l√Ω l·ªói token"""
    st.error("‚ùå Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.")
    clear_session()
    st.rerun()


def format_timestamp(timestamp: str) -> str:
    """Format timestamp"""
    try:
        dt = datetime.fromisoformat(timestamp.replace("Z", "+00:00"))
        return dt.strftime("%H:%M:%S")
    except Exception:
        return ""


def safe_format_title(title: str, max_length: int = 25) -> str:
    """Safely format title"""
    if not title:
        return "Cu·ªôc tr√≤ chuy·ªán"
    if len(title) > max_length:
        return title[:max_length] + "..."
    return title


# ================== API CLIENT ==================
class APIClient:
    """Client ƒë·ªÉ g·ªçi API"""

    @staticmethod
    async def make_request(
        method: str,
        endpoint: str,
        data: Optional[Dict] = None,
        token: Optional[str] = None,
        timeout: int = API_TIMEOUT,
    ) -> tuple[bool, Optional[Dict], str]:
        """Th·ª±c hi·ªán API request"""
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        headers = {"Content-Type": "application/json"}

        if token:
            headers["Authorization"] = f"Bearer {token}"

        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as session:
                async with session.request(
                    method, url, json=data, headers=headers
                ) as response:
                    if response.content_type == "application/json":
                        response_data = await response.json()
                    else:
                        response_data = {"message": await response.text()}

                    if response.status < 400:
                        return True, response_data, ""
                    else:
                        error_msg = response_data.get(
                            "detail", f"HTTP {response.status}"
                        )

                        # Check for token errors
                        if (
                            response.status in [401, 403]
                            or "token" in str(error_msg).lower()
                        ):
                            return False, response_data, "INVALID_TOKEN"

                        return False, response_data, error_msg

        except asyncio.TimeoutError:
            return False, None, "Request timeout"
        except aiohttp.ClientConnectorError:
            return False, None, "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn API server"
        except Exception as e:
            return False, None, f"L·ªói k·∫øt n·ªëi: {str(e)}"

    @staticmethod
    async def stream_request(
        endpoint: str, data: Dict, token: str, timeout: int = API_TIMEOUT
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """Th·ª±c hi·ªán streaming request"""
        url = f"{API_BASE_URL.rstrip('/')}/{endpoint.lstrip('/')}"
        headers = {
            "Authorization": f"Bearer {token}",
            "Content-Type": "application/json",
            "Accept": "text/event-stream",
        }

        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=timeout)
            ) as session:
                async with session.post(url, json=data, headers=headers) as response:
                    if response.status == 200:
                        async for line in response.content:
                            line = line.decode("utf-8").strip()
                            if line.startswith("data: "):
                                try:
                                    chunk_data = json.loads(line[6:])
                                    yield chunk_data
                                except json.JSONDecodeError:
                                    continue
                    else:
                        error_text = await response.text()
                        if response.status in [401, 403]:
                            yield {"type": "error", "content": "INVALID_TOKEN"}
                        else:
                            yield {
                                "type": "error",
                                "content": f"HTTP {response.status}: {error_text}",
                            }

        except Exception as e:
            yield {"type": "error", "content": f"Stream error: {str(e)}"}


# ================== SERVICES ==================
class AuthService:
    """Service x·ª≠ l√Ω authentication"""

    @staticmethod
    async def login(username: str, password: str) -> tuple[bool, Optional[Dict], str]:
        """ƒêƒÉng nh·∫≠p"""
        if not username or len(username) < 3:
            return False, None, "T√™n ƒëƒÉng nh·∫≠p ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±"

        if not password or len(password) < 6:
            return False, None, "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±"

        data = {"username": username, "password": password}
        success, response, error = await APIClient.make_request(
            "POST", "/auth/login", data
        )

        if success and response:
            return True, response, ""
        else:
            return False, None, error or "ƒêƒÉng nh·∫≠p th·∫•t b·∫°i"

    @staticmethod
    async def register(
        username: str, password: str
    ) -> tuple[bool, Optional[Dict], str]:
        """ƒêƒÉng k√Ω"""
        if not username or len(username) < 3:
            return False, None, "T√™n ƒëƒÉng nh·∫≠p ph·∫£i c√≥ √≠t nh·∫•t 3 k√Ω t·ª±"

        if not password or len(password) < 6:
            return False, None, "M·∫≠t kh·∫©u ph·∫£i c√≥ √≠t nh·∫•t 6 k√Ω t·ª±"

        data = {"username": username, "password": password}
        success, response, error = await APIClient.make_request(
            "POST", "/auth/register", data
        )

        if success and response:
            return True, response, ""
        else:
            return False, None, error or "ƒêƒÉng k√Ω th·∫•t b·∫°i"


class ChatService:
    """Service x·ª≠ l√Ω chat"""

    @staticmethod
    async def send_message_stream(
        message: str,
        token: str,
        conversation_id: Optional[str] = None,
        include_search_info: bool = False,
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """G·ª≠i tin nh·∫Øn v√† nh·∫≠n streaming response"""
        if not message or len(message.strip()) == 0:
            yield {"type": "error", "content": "Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng"}
            return

        if len(message) > MAX_MESSAGE_LENGTH:
            yield {
                "type": "error",
                "content": f"Tin nh·∫Øn kh√¥ng ƒë∆∞·ª£c qu√° {MAX_MESSAGE_LENGTH} k√Ω t·ª±",
            }
            return

        data = {
            "message": message.strip(),
            "conversation_id": conversation_id,
            "stream": True,
            "include_search_info": include_search_info,
        }

        async for chunk in APIClient.stream_request("/chat/", data, token):
            yield chunk

    @staticmethod
    async def get_conversations(token: str) -> tuple[bool, Optional[list], str]:
        """L·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán"""
        success, data, error = await APIClient.make_request(
            "GET", "/chat/conversations", token=token
        )

        if success and isinstance(data, list):
            return True, data, ""
        elif error == "INVALID_TOKEN":
            return False, None, "INVALID_TOKEN"
        else:
            return False, None, error or "Kh√¥ng th·ªÉ t·∫£i danh s√°ch cu·ªôc tr√≤ chuy·ªán"

    @staticmethod
    async def get_conversation_history(
        token: str, conversation_id: str
    ) -> tuple[bool, Optional[Dict], str]:
        """L·∫•y l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán"""
        endpoint = f"/chat/conversations/{conversation_id}"
        success, data, error = await APIClient.make_request(
            "GET", endpoint, token=token
        )

        if success and data:
            return True, data, ""
        elif error == "INVALID_TOKEN":
            return False, None, "INVALID_TOKEN"
        else:
            return False, None, error or "Kh√¥ng th·ªÉ t·∫£i l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán"


# ================== UI FUNCTIONS ==================
def add_message(role: str, content: str):
    """Th√™m tin nh·∫Øn v√†o session"""
    if "messages" not in st.session_state:
        st.session_state.messages = []

    st.session_state.messages.append(
        {"role": role, "content": content, "timestamp": datetime.now().isoformat()}
    )


def clear_conversation():
    """X√≥a cu·ªôc tr√≤ chuy·ªán hi·ªán t·∫°i"""
    st.session_state.messages = []
    st.session_state.current_conversation_id = None


def login_page():
    """Trang ƒëƒÉng nh·∫≠p"""
    st.title("ü§ñ Chatbot Gi·ªõi Thi·ªáu S·∫£n Ph·∫©m")
    st.markdown("---")

    tab1, tab2 = st.tabs(["ƒêƒÉng Nh·∫≠p", "ƒêƒÉng K√Ω"])

    with tab1:
        st.header("ƒêƒÉng Nh·∫≠p")
        with st.form("login_form"):
            username = st.text_input(
                "T√™n ƒëƒÉng nh·∫≠p", placeholder="Nh·∫≠p t√™n ƒëƒÉng nh·∫≠p..."
            )
            password = st.text_input(
                "M·∫≠t kh·∫©u", type="password", placeholder="Nh·∫≠p m·∫≠t kh·∫©u..."
            )
            submit_button = st.form_submit_button("üîê ƒêƒÉng Nh·∫≠p", type="primary")

            if submit_button:
                if username and password:
                    with st.spinner("üîê ƒêang ƒëƒÉng nh·∫≠p..."):
                        success, result, error = run_async(
                            AuthService.login(username, password)
                        )

                        if success and result:
                            st.session_state.authenticated = True
                            st.session_state.access_token = result["access_token"]
                            st.session_state.user_info = {
                                "user_id": result["user_id"],
                                "username": result["username"],
                            }
                            update_activity()
                            st.success("‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!")
                            time.sleep(1)
                            st.rerun()
                        else:
                            st.error(f"‚ùå {error}")
                else:
                    st.error("‚ùå Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin!")

    with tab2:
        st.header("ƒêƒÉng K√Ω")
        with st.form("register_form"):
            reg_username = st.text_input("T√™n ƒëƒÉng nh·∫≠p", key="reg_username")
            reg_password = st.text_input(
                "M·∫≠t kh·∫©u", type="password", key="reg_password"
            )
            reg_confirm_password = st.text_input("X√°c nh·∫≠n m·∫≠t kh·∫©u", type="password")
            register_button = st.form_submit_button("üìù ƒêƒÉng K√Ω", type="secondary")

            if register_button:
                if reg_username and reg_password and reg_confirm_password:
                    if reg_password != reg_confirm_password:
                        st.error("‚ùå M·∫≠t kh·∫©u x√°c nh·∫≠n kh√¥ng kh·ªõp!")
                    else:
                        with st.spinner("üìù ƒêang ƒëƒÉng k√Ω..."):
                            success, result, error = run_async(
                                AuthService.register(reg_username, reg_password)
                            )

                            if success:
                                st.success("‚úÖ ƒêƒÉng k√Ω th√†nh c√¥ng! Vui l√≤ng ƒëƒÉng nh·∫≠p.")
                            else:
                                st.error(f"‚ùå {error}")
                else:
                    st.error("‚ùå Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin!")


def sidebar():
    """Sidebar v·ªõi th√¥ng tin user v√† cu·ªôc tr√≤ chuy·ªán"""
    with st.sidebar:
        # User info
        user_info = st.session_state.get("user_info", {})
        st.header(f"üëã Xin ch√†o, {user_info.get('username', 'User')}")

        # Logout button
        if st.button("üö™ ƒêƒÉng xu·∫•t", type="secondary"):
            clear_session()
            st.success("üëã ƒê√£ ƒëƒÉng xu·∫•t th√†nh c√¥ng!")
            time.sleep(1)
            st.rerun()

        st.markdown("---")

        # New conversation
        if st.button("üí¨ Cu·ªôc tr√≤ chuy·ªán m·ªõi", type="primary"):
            clear_conversation()
            st.rerun()

        # Conversations
        st.subheader("üìù L·ªãch s·ª≠ tr√≤ chuy·ªán")

        # Refresh conversations
        if st.button("üîÑ T·∫£i l·∫°i"):
            token = st.session_state.get("access_token")
            if token and is_session_valid():
                with st.spinner("üìù ƒêang t·∫£i danh s√°ch cu·ªôc tr√≤ chuy·ªán..."):
                    success, conversations, error = run_async(
                        ChatService.get_conversations(token)
                    )

                    if success and conversations is not None:
                        # Filter valid conversations
                        valid_conversations = [
                            conv
                            for conv in conversations
                            if isinstance(conv, dict) and conv.get("id")
                        ]
                        st.session_state.conversations = valid_conversations
                        st.success(
                            f"‚úÖ ƒê√£ t·∫£i {len(valid_conversations)} cu·ªôc tr√≤ chuy·ªán"
                        )
                    elif error == "INVALID_TOKEN":
                        handle_token_error()
                    else:
                        st.error(f"‚ùå L·ªói t·∫£i danh s√°ch: {error}")
            else:
                handle_token_error()

        # Display conversations
        conversations = st.session_state.get("conversations", [])
        if conversations:
            for conv in conversations[:10]:  # Hi·ªÉn th·ªã t·ªëi ƒëa 10 cu·ªôc tr√≤ chuy·ªán
                conv_title = safe_format_title(conv.get("title"), 25)
                conv_id = conv.get("id")
                message_count = conv.get("message_count", 0)

                if conv_id and st.button(
                    f"üí¨ {conv_title} ({message_count})", key=f"conv_{conv_id}"
                ):
                    # Load conversation history
                    token = st.session_state.get("access_token")
                    if token and is_session_valid():
                        with st.spinner("üìú ƒêang t·∫£i l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán..."):
                            success, history, error = run_async(
                                ChatService.get_conversation_history(token, conv_id)
                            )

                            if success and history:
                                st.session_state.current_conversation_id = conv_id
                                st.session_state.messages = []

                                messages = history.get("messages", [])
                                for msg in messages:
                                    if msg.get("message") and msg.get("response"):
                                        add_message("user", msg["message"])
                                        add_message("assistant", msg["response"])

                                st.success(
                                    f"‚úÖ ƒê√£ t·∫£i l·ªãch s·ª≠ ({len(messages)} tin nh·∫Øn)"
                                )
                                st.rerun()
                            elif error == "INVALID_TOKEN":
                                handle_token_error()
                            else:
                                st.error(f"‚ùå L·ªói t·∫£i l·ªãch s·ª≠: {error}")
                    else:
                        handle_token_error()
        else:
            st.info("Ch∆∞a c√≥ cu·ªôc tr√≤ chuy·ªán n√†o")

        # Stats
        messages = st.session_state.get("messages", [])
        if messages:
            st.markdown("---")
            st.caption(f"üìä Cu·ªôc tr√≤ chuy·ªán hi·ªán t·∫°i: {len(messages)} tin nh·∫Øn")


def chat_interface():
    """Giao di·ªán chat ch√≠nh"""
    st.title("ü§ñ Chatbot T∆∞ V·∫•n S·∫£n Ph·∫©m")
    st.markdown("H·ªèi t√¥i b·∫•t c·ª© ƒëi·ªÅu g√¨ v·ªÅ s·∫£n ph·∫©m ƒëi·ªán t·ª≠!")

    # Check session validity
    if not is_session_valid():
        st.warning("‚è∞ Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.")
        clear_session()
        st.rerun()

    # Update activity
    update_activity()

    # Display messages
    messages = st.session_state.get("messages", [])
    for message in messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
            if message.get("timestamp"):
                st.caption(f"‚è∞ {format_timestamp(message['timestamp'])}")

    # Chat settings
    with st.sidebar:
        st.markdown("---")
        st.subheader("‚öôÔ∏è C√†i ƒë·∫∑t Chat")

        include_search = st.checkbox(
            "üîç Hi·ªÉn th·ªã th√¥ng tin t√¨m ki·∫øm",
            value=False,
            help="Hi·ªÉn th·ªã chi ti·∫øt v·ªÅ qu√° tr√¨nh t√¨m ki·∫øm",
        )

        if st.button("üóëÔ∏è X√≥a cu·ªôc tr√≤ chuy·ªán"):
            clear_conversation()
            st.success("ƒê√£ x√≥a cu·ªôc tr√≤ chuy·ªán")
            st.rerun()

    # Chat input
    if prompt := st.chat_input("üí¨ Nh·∫≠p c√¢u h·ªèi c·ªßa b·∫°n..."):
        # Add user message
        add_message("user", prompt)

        # Display user message
        with st.chat_message("user"):
            st.markdown(prompt)

        # Get bot response
        with st.chat_message("assistant"):
            message_placeholder = st.empty()
            full_response = ""
            search_info = None

            try:
                token = st.session_state.get("access_token")
                if not token or not is_session_valid():
                    st.error("‚ùå Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.")
                    handle_token_error()
                    return

                # Create status container for better loading UX
                status_container = st.status("ü§ñ ƒêang x·ª≠ l√Ω c√¢u h·ªèi...", expanded=True)

                try:
                    # Stream response
                    async def process_stream():
                        nonlocal full_response, search_info
                        first_chunk_received = False

                        with status_container:
                            async for chunk in ChatService.send_message_stream(
                                prompt,
                                token,
                                st.session_state.get("current_conversation_id"),
                                include_search,
                            ):
                                if chunk["type"] == "start":
                                    st.session_state.current_conversation_id = (
                                        chunk.get("conversation_id")
                                    )

                                elif chunk["type"] == "chunk":
                                    content = chunk.get("content", "")
                                    full_response += content

                                    # Update status and start showing content after first chunk
                                    if not first_chunk_received:
                                        status_container.update(
                                            label="‚úÖ ƒêang tr·∫£ l·ªùi...",
                                            state="running",
                                            expanded=False,
                                        )
                                        first_chunk_received = True

                                    # Show typing indicator
                                    message_placeholder.markdown(full_response + " ‚ñå")

                                elif chunk["type"] == "end":
                                    message_placeholder.markdown(full_response)
                                    status_container.update(
                                        label="‚úÖ Ho√†n th√†nh!", state="complete"
                                    )
                                    metadata = chunk.get("metadata", {})
                                    if metadata.get("search_info"):
                                        search_info = metadata["search_info"]

                                elif chunk["type"] == "error":
                                    error_content = chunk.get(
                                        "content", "Unknown error"
                                    )
                                    status_container.update(
                                        label="‚ùå C√≥ l·ªói x·∫£y ra", state="error"
                                    )
                                    if error_content == "INVALID_TOKEN":
                                        st.error("‚ùå Phi√™n ƒëƒÉng nh·∫≠p ƒë√£ h·∫øt h·∫°n.")
                                        handle_token_error()
                                        return
                                    else:
                                        st.error(f"‚ùå L·ªói: {error_content}")
                                        return

                    run_async(process_stream())

                    # Add response to history
                    if full_response:
                        add_message("assistant", full_response)

                    # Show search info if enabled
                    if search_info and include_search:
                        with st.expander("üîç Th√¥ng tin t√¨m ki·∫øm", expanded=False):
                            st.json(search_info)

                except Exception as stream_error:
                    # Update status on error
                    status_container.update(label="‚ùå L·ªói k·∫øt n·ªëi", state="error")
                    st.error(f"‚ùå L·ªói khi x·ª≠ l√Ω ph·∫£n h·ªìi: {str(stream_error)}")

            except Exception as e:
                st.error(f"‚ùå L·ªói khi g·ª≠i tin nh·∫Øn: {str(e)}")


def main():
    """H√†m main"""
    # Initialize session state
    init_session_state()

    # Main app logic
    if not st.session_state.get("authenticated", False):
        login_page()
    else:
        # Layout with sidebar
        sidebar()

        # Main chat interface
        chat_interface()

        # Footer
        st.markdown("---")
        st.markdown(
            "<div style='text-align: center; color: #666; font-size: 0.8em;'>"
            "ü§ñ Chatbot Gi·ªõi Thi·ªáu S·∫£n Ph·∫©m - Powered by LLM & Vector Search"
            "</div>",
            unsafe_allow_html=True,
        )


if __name__ == "__main__":
    main()  # C√°ch ch·∫°y: streamlit run src/streamlit/app.py
